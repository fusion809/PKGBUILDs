UPDADE: Use Perl macro SvREFCNT_inc_void_NN() instead of SvREFCNT()++
suggested by Ken Takata.

=for apidoc Am|void|SvREFCNT_inc_void_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

diff -r 030b239e7b25 src/if_perl.xs
--- a/src/if_perl.xs	Sun May 01 23:15:06 2016 +0200
+++ b/src/if_perl.xs	Mon May 02 08:17:33 2016 +0200
@@ -602,13 +602,20 @@ static struct {
 };
 
 /* Work around for perl-5.18.
- * The definitions of S_SvREFCNT_inc and S_SvREFCNT_dec are needed, so include
- * "perl\lib\CORE\inline.h", after Perl_sv_free2 is defined.
- * The linker won't complain about undefined __impl_Perl_sv_free2. */
+ * For now, only the definitions of S_SvREFCNT_dec are needed in
+ * "perl\lib\CORE\inline.h". */
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 18)
-# define PL_memory_wrap "panic: memory wrap" /* Dummy */
-# include <inline.h>
-# undef PL_memory_wrap
+static void
+S_SvREFCNT_dec(pTHX_ SV *sv)
+{
+    if (LIKELY(sv != NULL)) {
+	U32 rc = SvREFCNT(sv);
+	if (LIKELY(rc > 1))
+	    SvREFCNT(sv) = rc - 1;
+	else
+	    Perl_sv_free2(aTHX_ sv, rc);
+    }
+}
 #endif
 
 /*
@@ -777,7 +784,7 @@ newWINrv(SV *rv, win_T *ptr)
 	sv_setiv(ptr->w_perl_private, PTR2IV(ptr));
     }
     else
-	SvREFCNT_inc(ptr->w_perl_private);
+	SvREFCNT_inc_void_NN(ptr->w_perl_private);
     SvRV(rv) = ptr->w_perl_private;
     SvROK_on(rv);
     return sv_bless(rv, gv_stashpv("VIWIN", TRUE));
@@ -793,7 +800,7 @@ newBUFrv(SV *rv, buf_T *ptr)
 	sv_setiv(ptr->b_perl_private, PTR2IV(ptr));
     }
     else
-	SvREFCNT_inc(ptr->b_perl_private);
+	SvREFCNT_inc_void_NN(ptr->b_perl_private);
     SvRV(rv) = ptr->b_perl_private;
     SvROK_on(rv);
     return sv_bless(rv, gv_stashpv("VIBUF", TRUE));
